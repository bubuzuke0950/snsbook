# 8. 連想記憶のシミュレーション

## ファイル一覧
- `hopfield.c`: 連想記憶のコード
- `Makefile`: Makefile
- `README-ja.md`: 日本語の説明 (このファイル)

## コードの説明
いわゆるホップフィールドネットワークをスパイキングネットワークで実装した。クロストークとセル・アセンブリを
説明するためのものである。

## コンパイル方法
8.2.1項の通り`make`する。テキストでは`make`しただけでは実行はされないが、こちらは実行も同時にされるようにした
(他のコードとの一貫性のため)。もしコンパイルだけしたければ
```
node00:~/snsbook/code/part2/hopfield$ make hopfield
```
とすればよい。

## 実行方法
テキスト通りに実行すればよい。図8.2bのパターンを埋め込んだネットワークに対して、図8.3cを与えたときのネットワークの
活動が計算される。発火頻度の値は標準出力に出力される。フォーマットは
```
行番号 列番号 その位置のニューロンの発火頻度 (spikes/s)
```
である。これらから図8.3a, bを構成することができる。また、ニューロン`n`の膜電位は`n.dat` (nは整数)というファイルに
出力される。これを表示すれば図8.3cが得られる。具体的には以下のようにして作成した。
```
plot [800:1000][-70:10] '2.dat' t '' w l, '7.dat' t '' w l, '12.dat' t '' w l, '13.dat' t '' w l, '14.dat' t '' w l, '17.dat' t '' w l, '22.dat' t '' w l
```

与えるパターンは、関数`setInput`で設定している。現在のコードは以下の通りであり、パターン1 (`p1`, ＋模様) の左半分だけ
を与えている。ここを書き換えれば、別のパターンを与えることができる。
```
void setInput ( float * i_ext )
{
  for ( int32_t i = 0; i < NX; i++ ) {
    for ( int32_t j = 0; j < NY; j++ ) {
      i_ext [ j + NY * i ] = ( j < NX / 2 ) ? I_EXT * p1 [ i ] [ j ] : 0;
    }
  }
}
```
